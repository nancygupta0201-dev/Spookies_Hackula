<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pac-Man — Near-Classic Web Version</title>
  <style>
    /* Basic reset */
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial}
    body{display:flex;align-items:center;justify-content:center;background:#000;color:#fff}
    #gameWrap{display:flex;flex-direction:column;gap:12px;align-items:center}
    canvas{background:#000;border:6px solid #000;image-rendering:crisp-edges}
    .hud{display:flex;gap:12px;align-items:center;font-weight:600}
    .btn{background:#111;border:1px solid #333;padding:6px 10px;border-radius:6px;cursor:pointer}
    .small{font-size:12px;color:#ddd}
    /* Scales canvas nicely on high-DPI */
  </style>
</head>
<body>
  <div id="gameWrap">
    <div class="hud">
      <div>Score: <span id="score">0</span></div>
      <div>Lives: <span id="lives">3</span></div>
      <button id="restart" class="btn">Restart</button>
      <div class="small">Controls: Arrow keys or WASD</div>
    </div>
    <canvas id="c" width="448" height="496"></canvas>
    <div class="small">This is a close recreation: maze, pellets, power pellets, ghosts with chase/scatter/frightened modes, simple fruit spawn.</div>
  </div>

<script>
// Pac-Man near-classic single-file implementation.
// Features:
// - Grid-based maze with pellets & power pellets
// - Pac-Man movement with smooth interpolation
// - 4 ghosts with different target behaviors (approximate classic AI)
// - Mode system: scatter / chase / frightened
// - Score, lives, restart
// Limitations: simplified movement speeds and tunnel wrap, no sound assets included.

(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const SCORE_EL = document.getElementById('score');
  const LIVES_EL = document.getElementById('lives');
  const RESTART_BTN = document.getElementById('restart');

  const TILE = 16; // game tile size
  const COLS = 28; // classic pac-man width
  const ROWS = 31; // classic pac-man height-ish
  const SCALE = 2; // scales drawing from internal tile size
  // Internal rendered resolution set by canvas attributes above (448x496 -> 16*28 = 448 width)

  // Colors
  const COLORS = {
    wall: '#00008B',
    wallStroke: '#0000CD',
    pellet: '#ffee99',
    power: '#fff',
    pacman: '#FFD700',
    blinky: '#FF0000',
    pinky: '#FFB8F0',
    inky: '#00FFFF',
    clyde: '#FFA500',
    frightened: '#0000FF'
  };

  // Maze layout: 0 empty, 1 wall, 2 pellet, 3 power pellet, 4 ghost house floor
  // This is a simplified (but similar) Pac-Man maze adapted for 28x31.
  // For readability we store as strings per row then map to numbers.
  const MAP_STR = [
"1111111111111111111111111111",
"1000000000110000000000000001",
"1011111110110111111111111101",
"1030000010001000001000000301",
"1011111011110111110111111101",
"1000001010000000010100000001",
"1111101010111111010101111111",
"0000101010001000010101000000",
"1111101011110111110101111111",
"1000000000010000000000000001",
"1011111111110111111111111101",
"1000000000000000000000000001",
"1111111011110111111011111111",
"0000000010000000000100000000",
"1111111010111111010111111111",
"1000000000100000010000000001",
"1011111110110111111111111101",
"1030000010001000001000000301",
"1011111011110111110111111101",
"1000001000000000010000000001",
"1111101010111111010101111111",
"0000101010001000010101000000",
"1111101011110111110101111111",
"1000000000010000000000000001",
"1011111111110111111111111101",
"1000000000000000000000000001",
"1111111111111111111111111111",
"0000000000000000000000000000",
"0000000000000000000000000000",
"0000000000000000000000000000",
"0000000000000000000000000000",
];

  // Convert string map to numeric map, placing pellets (2) on empty (0) tiles mostly
  const map = [];
  for (let r=0;r<MAP_STR.length;r++){
    const row = [];
    const s = MAP_STR[r];
    for (let c=0;c<s.length;c++){
      const ch = s[c];
      let v = parseInt(ch,10);
      // Fill empty spaces (0) with pellets (2) except inside the bottom rows that are used for UI
      if (v === 0) v = 2;
      row.push(v);
    }
    map.push(row);
  }

  // Playback / game state
  let score = 0;
  let lives = 3;
  let pelletsLeft = countPellets();

  function countPellets(){
    let c=0; for(let r=0;r<map.length;r++)for(let col=0;col<map[r].length;col++){ if(map[r][col]===2||map[r][col]===3) c++; } return c; }

  // Pac-Man state
  const pac = {
    x: 14, y: 23, // grid position
    px: 14, py: 23, // precise pixel positions in tiles
    dir: {x:0,y:0}, nextDir: {x:0,y:0}, speed: 5/16, // tiles per frame (fractional)
    mouth:0
  };

  // Ghost states
  const GHOSTS = [
    {name:'blinky', color:COLORS.blinky, x:14, y:11, mode:'scatter', speed:4/16, scatterTarget:[25,0]},
    {name:'pinky', color:COLORS.pinky, x:13, y:14, mode:'scatter', speed:3.5/16, scatterTarget:[2,0]},
    {name:'inky',  color:COLORS.inky,  x:14, y:14, mode:'scatter', speed:3.5/16, scatterTarget:[25,31]},
    {name:'clyde', color:COLORS.clyde, x:15, y:14, mode:'scatter', speed:3/16, scatterTarget:[0,31]},
  ];

  // Mode system (simplified timers in frames at 60fps)
  const MODE_SCHEDULE = [ {mode:'scatter',frames:7*60}, {mode:'chase',frames:20*60}, {mode:'scatter',frames:7*60}, {mode:'chase',frames:20*60}, {mode:'scatter',frames:5*60}, {mode:'chase',frames:20*60}, {mode:'scatter',frames:5*60}, {mode:'chase',frames:9999999}];
  let modeIndex = 0; let modeTimer = MODE_SCHEDULE[0].frames; let globalMode = MODE_SCHEDULE[0].mode;

  // frightened mode
  let frightened = false; let frightenedTimer = 0;

  // Ghost objects with positions in tiles plus precise positions
  const ghosts = GHOSTS.map(g => ({...g, gx:g.x, gy:g.y, px:g.x, py:g.y, dir:{x:0,y:0}, state:'alive'}));

  // Keyboard
  const keys = {};
  window.addEventListener('keydown',e=>{ keys[e.key.toLowerCase()]=true; if(e.key.includes('Arrow')) e.preventDefault(); });
  window.addEventListener('keyup',e=>{ keys[e.key.toLowerCase()]=false; });

  RESTART_BTN.addEventListener('click', restart);

  function restart(){
    // reset map pellets
    for(let r=0;r<map.length;r++) for(let c=0;c<map[r].length;c++){ if(map[r][c]===0) map[r][c]=2; }
    score=0; lives=3; pelletsLeft=countPellets();
    pac.x=14; pac.y=23; pac.px=14; pac.py=23; pac.dir={x:0,y:0}; pac.nextDir={x:0,y:0};
    ghosts.forEach((g,i)=>{ g.gx=GHOSTS[i].x; g.gy=GHOSTS[i].y; g.px=g.gx; g.py=g.gy; g.dir={x:0,y:0}; g.state='alive'; });
    modeIndex=0; modeTimer=MODE_SCHEDULE[0].frames; globalMode=MODE_SCHEDULE[0].mode; frightened=false; frightenedTimer=0;
    updateHUD();
  }

  function updateHUD(){ SCORE_EL.textContent = score; LIVES_EL.textContent = lives; }

  function isWall(r,c){ if(r<0||r>=map.length||c<0||c>=map[0].length) return true; return map[r][c]===1; }

  function canMoveTo(r,c){ // allow moving into pellets and empty and power pellets and ghost house floors
    if(r<0||c<0||r>=map.length||c>=map[0].length) return false;
    return map[r][c]!==1;
  }

  function readInput(){
    let nx=0, ny=0;
    if(keys['arrowleft']||keys['a']) nx=-1;
    if(keys['arrowright']||keys['d']) nx=1;
    if(keys['arrowup']||keys['w']) ny=-1;
    if(keys['arrowdown']||keys['s']) ny=1;
    // normalize to axis aligned choice
    if(Math.abs(nx)>0 && Math.abs(ny)>0) { ny=0; }
    pac.nextDir = {x:nx,y:ny};
  }

  function stepPac(){
    // if centered in tile, attempt to change direction
    const centerX = Math.abs(pac.px - Math.round(pac.px)) < 0.001;
    const centerY = Math.abs(pac.py - Math.round(pac.py)) < 0.001;
    if(centerX && centerY){
      pac.x = Math.round(pac.px);
      pac.y = Math.round(pac.py);
      // if nextDir feasible commit to it
      if(pac.nextDir.x!==0 || pac.nextDir.y!==0){
        const nx = pac.x + pac.nextDir.x, ny = pac.y + pac.nextDir.y;
        if(canMoveTo(ny,nx)) pac.dir = {...pac.nextDir};
      }
      // check forward move still valid
      const fx = pac.x + pac.dir.x, fy = pac.y + pac.dir.y;
      if(!canMoveTo(fy,fx)) pac.dir = {x:0,y:0};

      // eat pellets
      if(map[pac.y] && map[pac.y][pac.x]===2){ map[pac.y][pac.x]=0; score += 10; pelletsLeft--; }
      if(map[pac.y] && map[pac.y][pac.x]===3){ map[pac.y][pac.x]=0; score += 50; pelletsLeft--; frightened = true; frightenedTimer = 10*60; }

      if(pelletsLeft<=0){ // win -> restart level
        score += 1000; restart();
      }
    }
    // move smoothly
    pac.px += pac.dir.x * pac.speed;
    pac.py += pac.dir.y * pac.speed;
    // wrap tunnels horizontally
    if(pac.px < -1) pac.px = map[0].length -1;
    if(pac.px > map[0].length) pac.px = 0;
  }

  // Simple BFS to find path on tile graph
  function findPath(sx,sy,tx,ty){
    const rows = map.length, cols = map[0].length;
    const q = [];
    const seen = new Array(rows).fill(0).map(()=>new Array(cols).fill(false));
    const from = new Array(rows).fill(0).map(()=>new Array(cols).fill(null));
    q.push([sx,sy]); seen[sy][sx]=true;
    while(q.length){
      const [cx,cy] = q.shift();
      if(cx===tx && cy===ty) break;
      const neighbors = [[1,0],[-1,0],[0,1],[0,-1]];
      for(const [dx,dy] of neighbors){
        const nx = cx+dx, ny = cy+dy;
        if(nx<0||ny<0||ny>=rows||nx>=cols) continue;
        if(seen[ny][nx]) continue;
        if(!canMoveTo(ny,nx)) continue;
        seen[ny][nx]=true; from[ny][nx]=[cx,cy]; q.push([nx,ny]);
      }
    }
    // reconstruct path
    if(!seen[ty] || !seen[ty][tx]) return null;
    const path = [];
    let cx = tx, cy = ty;
    while(!(cx===sx && cy===sy)){
      path.push([cx,cy]);
      const f = from[cy][cx]; if(!f) break; cx=f[0]; cy=f[1];
    }
    path.reverse(); return path;
  }

  function stepGhosts(){
    ghosts.forEach(g => {
      // mode logic
      if(frightened){ g.mode='frightened'; } else { g.mode = globalMode; }
      // If in frightened and reached a tile, randomize next direction
      if(Math.abs(g.px - Math.round(g.px))<0.01 && Math.abs(g.py - Math.round(g.py))<0.01){
        g.gx = Math.round(g.px); g.gy = Math.round(g.py);
        // determine target
        let tx = pac.x, ty = pac.y;
        if(g.name==='blinky'){ tx = pac.x; ty = pac.y; }
        else if(g.name==='pinky'){ // ambush 4 tiles ahead of pacman
          tx = pac.x + pac.dir.x * 4; ty = pac.y + pac.dir.y * 4; }
        else if(g.name==='inky'){ // uses vector from blinky to a point 2 ahead of pacman
          const bl = ghosts.find(x=>x.name==='blinky');
          const ax = pac.x + pac.dir.x*2, ay = pac.y + pac.dir.y*2;
          tx = ax + (ax - bl.gx); ty = ay + (ay - bl.gy);
        }
        else if(g.name==='clyde'){
          const dist = Math.hypot(g.gx-pac.x,g.gy-pac.y);
          if(dist>8) { tx = pac.x; ty = pac.y; } else { tx = g.scatterTarget[0]; ty = g.scatterTarget[1]; }
        }
        if(g.mode==='scatter'){ tx = g.scatterTarget[0]; ty = g.scatterTarget[1]; }
        if(g.mode==='frightened'){ // random target
          tx = Math.floor(Math.random()*map[0].length); ty = Math.floor(Math.random()*map.length);
        }
        // clamp
        tx = Math.max(0, Math.min(map[0].length-1, Math.round(tx)));
        ty = Math.max(0, Math.min(map.length-1, Math.round(ty)));
        // compute path and pick next step
        const path = findPath(g.gx,g.gy, tx, ty);
        if(path && path.length>0){
          const nx = path[0][0], ny = path[0][1];
          g.dir = {x: nx - g.gx, y: ny - g.gy};
        } else {
          // random wander
          const options = [[1,0],[-1,0],[0,1],[0,-1]].filter(([dx,dy]) => canMoveTo(g.gy+dy, g.gx+dx));
          if(options.length) { const o = options[Math.floor(Math.random()*options.length)]; g.dir={x:o[0], y:o[1]}; }
        }
      }

      // move
      g.px += g.dir.x * g.speed;
      g.py += g.dir.y * g.speed;
    });
  }

  function checkCollisions(){
    ghosts.forEach(g=>{
      const dx = Math.abs(g.px - pac.px), dy = Math.abs(g.py - pac.py);
      if(dx < 0.5 && dy < 0.5){
        if(frightened && g.state==='alive'){
          // eat ghost
          score += 200; g.state = 'eaten';
          // send to ghost house
          g.px = 14; g.py = 11; g.gx = 14; g.gy = 11;
        } else if(!frightened && g.state==='alive'){
          // pacman dies
          lives -= 1; updateHUD();
          if(lives<=0){ alert('Game Over — Score: ' + score); restart(); }
          else {
            // reset positions
            pac.x=14; pac.y=23; pac.px=14; pac.py=23; pac.dir={x:0,y:0};
            ghosts.forEach((gg,i)=>{ gg.px=GHOSTS[i].x; gg.py=GHOSTS[i].y; gg.gx=GHOSTS[i].x; gg.gy=GHOSTS[i].y; gg.dir={x:0,y:0}; gg.state='alive'; });
          }
        }
      }
    });
  }

  // Mode ticking
  function modeTick(){
    if(frightened){ frightenedTimer--; if(frightenedTimer<=0){ frightened=false; } }
    modeTimer--; if(modeTimer<=0){ modeIndex = Math.min(modeIndex+1, MODE_SCHEDULE.length-1); globalMode = MODE_SCHEDULE[modeIndex].mode; modeTimer = MODE_SCHEDULE[modeIndex].frames; }
  }

  // Drawing helpers
  function drawTile(r,c){
    const val = map[r][c];
    const px = c * TILE, py = r * TILE;
    // walls
    if(val===1){ ctx.fillStyle = COLORS.wall; ctx.fillRect(px,py,TILE,TILE); ctx.strokeStyle=COLORS.wallStroke; ctx.strokeRect(px+1,py+1,TILE-2,TILE-2); }
    // pellets
    if(val===2){ ctx.fillStyle=COLORS.pellet; ctx.beginPath(); ctx.arc(px+TILE/2, py+TILE/2, 2, 0, Math.PI*2); ctx.fill(); }
    if(val===3){ ctx.fillStyle=COLORS.power; ctx.beginPath(); ctx.arc(px+TILE/2, py+TILE/2, 5, 0, Math.PI*2); ctx.fill(); }
  }

  function drawPac(){
    const x = pac.px * TILE + TILE/2; const y = pac.py * TILE + TILE/2;
    pac.mouth = (Math.sin(Date.now()/100)+1)/2*0.35;
    const angle = Math.atan2(pac.dir.y, pac.dir.x);
    let start = 0.25 - pac.mouth, end = 1.75 + pac.mouth;
    // default facing right
    if(pac.dir.x===-1) { start += Math.PI; end += Math.PI; }
    if(pac.dir.y===-1) { start -= Math.PI/2; end -= Math.PI/2; }
    if(pac.dir.y===1)  { start += Math.PI/2; end += Math.PI/2; }
    ctx.fillStyle = COLORS.pacman; ctx.beginPath(); ctx.moveTo(x,y);
    ctx.arc(x,y, TILE/2 -1, start*Math.PI, end*Math.PI); ctx.closePath(); ctx.fill();
  }

  function drawGhost(g){
    const x = g.px * TILE + TILE/2; const y = g.py * TILE + TILE/2;
    ctx.save();
    ctx.translate(x,y);
    ctx.beginPath(); ctx.moveTo(-TILE/2+1, TILE/4);
    ctx.lineTo(-TILE/2+1, -TILE/2+1);
    ctx.quadraticCurveTo(0,-TILE/2-2, TILE/2-1, -TILE/2+1);
    ctx.lineTo(TILE/2-1, TILE/4);
    // wavy bottom
    const wig = TILE/8;
    ctx.lineTo(TILE/4, TILE/2-1);
    ctx.lineTo(0, TILE/4);
    ctx.lineTo(-TILE/4, TILE/2-1);
    ctx.closePath();
    ctx.fillStyle = (frightened && g.state==='alive') ? COLORS.frightened : g.color;
    ctx.fill();
    // eyes
    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(-TILE/6, -TILE/8, TILE/8,0,Math.PI*2); ctx.arc(TILE/6, -TILE/8, TILE/8,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(-TILE/6 + g.dir.x*2, -TILE/8 + g.dir.y*2, TILE/16,0,Math.PI*2); ctx.arc(TILE/6 + g.dir.x*2, -TILE/8 + g.dir.y*2, TILE/16,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }

  function render(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // draw tiles
    for(let r=0;r<map.length;r++) for(let c=0;c<map[r].length;c++){ drawTile(r,c); }
    // draw pac
    drawPac();
    // draw ghosts
    ghosts.forEach(g=> drawGhost(g));
    // HUD overlay (score/lives handled by DOM)
  }

  // Main loop
  function frame(){
    readInput();
    stepPac();
    stepGhosts();
    checkCollisions();
    modeTick();
    render();
    updateHUD();
    requestAnimationFrame(frame);
  }

  // initialize and run
  updateHUD();
  frame();

})();
</script>
</body>
</html>
